#' @title Compute fitted mortality rate
#'
#' @description
#' Calculate the empirical mortality rate over a given interval
#' on some new data.
#'
#' @param lifelihoodResults A `lifelihoodResults` object
#' @inheritParams compute_observed_mortality_rate
#'
#' @return A dataframe with 3 columns: Interval (time interval, based
#' on `interval_width` value), group (identifier of a given subgroup,
#' or "Overall" if groupby = NULL), and Event_rate (event rate
#' at this time).
#'
#' @import dplyr
#'
#' @export
compute_fitted_mortality_rate <- function(
  lifelihoodResults,
  interval_width,
  event = c("mortality", "maturity", "reproduction"),
  newdata = NULL,
  max_time = NULL,
  groupby = NULL
) {
  event <- match.arg(event)
  check_valid_lifelihoodResults(lifelihoodResults)

  lifelihoodData <- lifelihoodResults$lifelihoodData

  if (event == "mortality") {
    start_col <- lifelihoodData$death_start
    end_col <- lifelihoodData$death_end
    family <- lifelihoodData$model_specs[1]
    covar <- c(
      lifelihoodResults$formula$expt_death,
      lifelihoodResults$formula$survival_param2
    ) |>
      unique() |>
      setdiff("intercept")
  } else if (event == "maturity") {
    start_col <- lifelihoodData$maturity_start
    end_col <- lifelihoodData$maturity_end
    family <- lifelihoodData$model_specs[2]
    covar <- c(
      lifelihoodResults$formula$expt_maturity,
      lifelihoodResults$formula$maturity_param2
    ) |>
      unique() |>
      setdiff("intercept")
  } else if (event == "reproduction") {
    start_col <- NULL
    end_col <- NULL
    family <- lifelihoodData$model_specs[3]
    covar <- c(
      lifelihoodResults$formula$expt_reproduction,
      lifelihoodResults$formula$reproduction_param2
    ) |>
      unique() |>
      setdiff("intercept")
  }

  if (!all(groupby %in% covar)) {
    missing_vars <- groupby[!groupby %in% covar]
    stop(
      "`groupby` argument contains invalid values. ",
      paste0(
        "Covariate(s) `",
        paste0(missing_vars, collapse = ", "),
        "` not fitted for event `",
        event,
        "` in the `lifelihoodResults` object provided"
      ),
      ".\n",
      paste0(
        "Fitted covariate(s) for`",
        event,
        "` event: ",
        paste0(covar, collapse = ", ")
      )
    )
  }
  if (is.null(max_time)) {
    sorted_values <- sort(
      unique(lifelihoodData$df[[end_col]]),
      decreasing = TRUE,
      na.last = NA
    )
    if (sorted_values[1] == lifelihoodData$right_censoring_date) {
      max_time <- sorted_values[2]
    } else {
      max_time <- sorted_values[1]
    }
  }

  n_intervals <- ceiling(max_time / interval_width) - 1

  if (is.null(newdata)) {
    params <- setNames(
      lapply(covar, function(x) levels(as.factor(lifelihoodData$df[[x]]))),
      covar
    )
    params$time <- seq(
      from = 0,
      to = (n_intervals-1) * interval_width,
      by = interval_width
    )
    newdata <- expand.grid(params) |> relocate(time)
    newdata <- newdata |>
      dplyr::mutate(
        Interval_start = time,
        Interval_end = time + interval_width,
        Mean_Interval = time + interval_width / 2
      )
  }

  if (!is.null(groupby)) {
    ## Remove interactions not present in original dataset
    newdata <- newdata |>
      dplyr::mutate(Group_tmp = interaction(newdata[groupby])) |>
      dplyr::filter(
        Group_tmp %in% unique(interaction(lifelihoodData$df[groupby]))
      ) |>
      dplyr::select(-Group_tmp)

    newdata <- newdata |>
      dplyr::arrange(across(all_of(groupby))) |>
      dplyr::mutate(across(
        all_of(groupby),
        ~ paste0(cur_column(), "=", .),
        .names = "{.col}"
      )) |>
      tidyr::unite("group", all_of(groupby), sep = ".", remove = FALSE)
  } else {
    newdata$group <- "Overall"
  }

  newdata$group <- as.factor(newdata$group)

  if (event == "mortality") {
    parameter_name1 <- "expt_death"
    parameter_name2 <- "survival_param2"
  } else if (event == "maturity") {
    parameter_name1 <- "expt_maturity"
    parameter_name2 <- "maturity_param2"
  } else if (event == "reproduction") {
    parameter_name1 <- "expt_reproduction"
    parameter_name2 <- "reproduction_param2"
  }

  param1 <- prediction(
    object = lifelihoodResults,
    parameter_name = parameter_name1,
    newdata = newdata,
    type = "response"
  )
  param2 <- prediction(
    object = lifelihoodResults,
    parameter_name = parameter_name2,
    newdata = newdata,
    type = "response"
  )

  newdata$Event_Rate <- prob_event_interval_dt(
    t = newdata$time,
    dt = interval_width,
    param1 = param1,
    param2 = param2,
    family = family
  )

  if (event == "reproduction") {
    newdata$n_offspring <- prediction(
      lifelihoodResults,
      parameter_name = "n_offspring",
      newdata = newdata
    )
  }
  return(newdata)
}

#' @title Compute empirical mortality rate
#'
#' @description
#' Calculate the empirical mortality rate over a given interval.
#'
#' @inheritParams lifelihood
#' @inheritParams validate_groupby_arg
#' @param interval_width The interval width used to calculate the
#' mortality rate. For instance, if the time unit for deaths in
#' the original dataset is days and `interval_width` is set to 10,
#' the mortality rate will be calculated every 10 days for each group.
#' @param newdata Data for computation. If absent, predictions are for
#' the subjects used in the original fit.
#' @param max_time The maximum time for calculating the mortality
#' rate. If set to NULL, the time of the last observed death is used.
#' @param min_sample_size The minimum number of individuals alive
#' at the beggining of a time interval for computing the observed mortality rate
#'
#' @return A dataframe with 3 columns: Interval (time interval, based
#' on `interval_width` value), group (identifier of a given subgroup,
#' or "Overall" if groupby = NULL), and Event_rate (event rate
#' at this time).
#'
#' @importFrom dplyr mutate if_else select
#' @export
#' @keywords internal
#'
#' @examples
#' library(lifelihood)
#' library(tidyverse)
#'
#' df <- fakesample |>
#'   mutate(
#'     geno = as.factor(geno),
#'     type = as.factor(type)
#'   )
#'
#' clutchs <- c(
#'   "clutch_start1", "clutch_end1", "clutch_size1",
#'   "clutch_start2", "clutch_end2", "clutch_size2"
#' )
#'
#' dataLFH <- lifelihoodData(
#'   df = df,
#'   sex = "sex",
#'   sex_start = "sex_start",
#'   sex_end = "sex_end",
#'   maturity_start = "mat_start",
#'   maturity_end = "mat_end",
#'   clutchs = clutchs,
#'   death_start = "death_start",
#'   death_end = "death_end",
#'   covariates = c("geno", "type"),
#'   model_specs = c("gam", "lgn", "wei")
#' )
#'
#' mort_df <- compute_observed_mortality_rate(dataLFH, interval_width = 2)
#' head(mort_df)
#'
#' mort_df <- compute_observed_mortality_rate(
#'   dataLFH,
#'   interval_width = 2,
#'   groupby = NULL,
#'   max_time = 170
#' )
#' head(mort_df)
compute_observed_mortality_rate <- function(
  lifelihoodData,
  interval_width,
  newdata = NULL,
  max_time = NULL,
  min_sample_size = 1,
  groupby = NULL
) {
  groupby <- validate_groupby_arg(lifelihoodData, groupby)

  if (is.null(newdata)) {
    newdata <- lifelihoodData$df
  } else {
    newdata <- newdata
  }
  start_col <- lifelihoodData$death_start
  end_col <- lifelihoodData$death_end
  covariates <- lifelihoodData$covariates
  right_censoring_date <- lifelihoodData$right_censoring_date

  if (is.null(max_time)) {
    sorted_values <- sort(
      unique(lifelihoodData$df[[end_col]]),
      decreasing = TRUE,
      na.last = NA
    )
    if (sorted_values[1] == right_censoring_date) {
      max_time <- sorted_values[2]
    } else {
      max_time <- sorted_values[1]
    }
  }

  n_intervals <- ceiling(max_time / interval_width)

  if (!is.null(groupby)) {
    ## Add group column to newdata
    newdata <- newdata |>
      dplyr::arrange(across(all_of(groupby))) |>
      dplyr::mutate(across(
        all_of(groupby),
        ~ paste0(cur_column(), "=", .),
        .names = "{.col}_tmp"
      )) |> ## Add the name of the columns to the group
      tidyr::unite(
        "group",
        all_of(paste0(groupby, "_tmp")),
        sep = ".",
        remove = FALSE
      ) |>
      dplyr::mutate(group = as.factor(group))

    groups <- levels(newdata$group)

    ## creates a empty dataframe where the estimated event rates will be stored
    params <- setNames(
      lapply(groupby, function(x) levels(as.factor(lifelihoodData$df[[x]]))),
      groupby
    )
    params$time <- seq(
      from = 0,
      to = (n_intervals-1) * interval_width,
      by = interval_width
    )

    event_rate <- expand.grid(params) |> relocate(time)

    ## Add group
    event_rate <- event_rate |>
      dplyr::mutate(across(
        all_of(groupby),
        ~ paste0(cur_column(), "=", .),
        .names = "{.col}"
      )) |> ## Add the name of the factor to each level
      tidyr::unite("group", all_of(groupby), sep = ".", remove = FALSE) |>
      dplyr::filter(group %in% groups) |> ## Remove interactions not present in original dataset
      dplyr::mutate(group = as.factor(group))
  } else {
    newdata$group <- "Overall"
    groups <- "Overall"

    event_rate <- expand.grid(
      time = seq(
        from = 0,
        to = n_intervals * interval_width,
        by = interval_width
      ),
      group = "Overall"
    )
  }

  event_rate <- event_rate |>
    dplyr::mutate(
      Interval_start = time,
      Interval_end = time + interval_width,
      Mean_Interval = time + interval_width / 2
    )

  event_rate$Event_Rate <- 0

  for (grp in groups) {
    group_data <- newdata[newdata$group == grp, ]

    for (i in 1:n_intervals) {
      interval_start <- (i - 1) * interval_width
      interval_end <- i * interval_width

      ## Number of individuals alive at the beggining of the time interval
      alive_start <- sum(
        group_data[[start_col]] >= interval_start &
          group_data[[end_col]] != right_censoring_date |
          group_data[[start_col]] >= interval_end & ## Count censored individuals only if censoring date posterior to end of interval
            group_data[[end_col]] == right_censoring_date
      )

      ## Number of individuals dead at the end of the time interval
      deaths <- sum(
        group_data[[start_col]] >= interval_start &
          group_data[[end_col]] < interval_end
      )

      event_rate$Event_Rate[
        event_rate$time == interval_start & event_rate$group == grp
      ] <- if (alive_start > min_sample_size) {
        deaths / alive_start
      } else {
        NA
      }
    }
  }

  if (is.null(groupby)) {
    event_rate <- event_rate |> select(-group)
  }

  return(event_rate)
}

#' @title Check that the `groupby` argument is valid
#'
#' @description
#' Check that `groupby` has an expected value, and returns it
#'
#' @inheritParams lifelihood
#' @param groupby vector of covariate(s) over which mortality rate should be
#' computed (default is `NULL`).
#' - If NULL, calculates a single overall mortality rate.
#' - If `"all"`, calculates mortality rate over each combination
#' of covariates listed in the`lifelihoodData` object provided.
#' - Otherwise must be a character (`"covariate1"`) or a
#' character vector (`c("covariate1", "covariate2")`).
#' Note that the function will consider continuous covariates as factors
#'
#' @returns The valid `groupby` value
#'
#' @keywords internal
validate_groupby_arg <- function(lifelihoodData, groupby) {
  if (is.null(groupby)) {
    return(NULL)
  } else if (length(groupby) == 1 && groupby == "all") {
    return(lifelihoodData$covariates)
  } else {
    covariates <- lifelihoodData$covariates

    if (!all(groupby %in% covariates)) {
      missing_vars <- groupby[!groupby %in% covariates]
      stop(
        "`groupby` argument contains invalid values. ",
        "These are not in the covariates of the `lifelihoodData` object: ",
        paste0(missing_vars, collapse = ", "),
        ".\n",
        "Valid covariates are: ",
        paste0(covariates, collapse = ", ")
      )
    } else {
      return(groupby)
    }
  }
}
